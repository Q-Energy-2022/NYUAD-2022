{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"qudra | \u0642\u064f\u062f\u0631\u0629","text":"<p>Quantum Energy Management</p> <p> </p>"},{"location":"#motivation","title":"Motivation","text":"<p>qudra:  power, capacity, ability</p> <p>Leveraging quantum advantage to optimize distributed grids for energy security and sustainability.</p> <p>Please check out these slides for more information.</p>"},{"location":"#installation","title":"Installation","text":"<p>Conda users, please make sure to <code>conda install pip</code> before running any pip installation if you want to install <code>qudra</code> into your conda environment.</p> <p><code>qudra</code> is published on PyPI. So, to install, simply run:</p> <pre><code>pip install qudra\n</code></pre> <p>If you also want to download the dependencies needed to run optional tutorials, please use <code>pip install qudra[dev]</code> or <code>pip install 'qudra[dev]'</code> (for <code>zsh</code> users).</p> <p>To check if the installation was successful, run:</p> <pre><code>&gt;&gt;&gt; import qudra\n</code></pre>"},{"location":"#building-from-source","title":"Building from source","text":"<p>To build <code>qudra</code> from source, pip install using:</p> <pre><code>git clone https://github.com/qcenergy/qudra.git\ncd qudra\npip install --upgrade .\n</code></pre> <p>If you also want to download the dependencies needed to run optional tutorials, please use <code>pip install --upgrade .[dev]</code> or <code>pip install --upgrade '.[dev]'</code> (for <code>zsh</code> users).</p>"},{"location":"#installation-for-devs","title":"Installation for Devs","text":"<p>If you intend to contribute to this project, please install <code>qudra</code> in editable mode as follows:</p> <pre><code>git clone https://github.com/qcenergy/qudra.git\ncd qudra\npip install -e .[dev]\n</code></pre> <p>python3 -m venv venv . venv/bin/activate Please use <code>pip install -e '.[dev]'</code> if you are a <code>zsh</code> user.</p>"},{"location":"#building-documentation-locally","title":"Building documentation locally","text":"<p>Set yourself up to use the <code>[dev]</code> dependencies. Then, from the command line run:</p> <pre><code>mkdocs build\n</code></pre> <p>Then, when you're ready to deploy, run:</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Core Devs: Asil Qraini, Fouad Afiouni, Gargi Chandrakar, Nurgazy Seidaliev, Sahar Ben Rached, Salem Al Haddad, Sarthak Prasad Malla</p> <p>Mentors: Akash Kant, Shantanu Jha</p> <p>This project was created at the 2022 NYUAD Hackathon for Social Good in the Arab World: Focusing on Quantum Computing (QC). </p>"},{"location":"reference/summary/","title":"Summary","text":"<ul> <li>qudra<ul> <li>optimizers<ul> <li>distributed_energy</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/qudra/","title":"qudra","text":"<p>qudra: quantum energy management</p>"},{"location":"reference/qudra/optimizers/","title":"optimizers","text":"<p>Optimizers</p>"},{"location":"reference/qudra/optimizers/distributed_energy/","title":"distributed_energy","text":"<p>DistributedEnergyOptimizer</p>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer","title":"<code>DistributedEnergyOptimizer</code>","text":"<p>Optimizing unit commitment from a distributed energy network.</p> The optimizer has been adapted from the work in <p>Akshay Ajagekar and Fengqi You. Quantum computing for energy systems optimization: Challenges and opportunities. Energy 179 (2019). https://doi.org/10.1016/j.energy.2019.04.186</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>class DistributedEnergyOptimizer:\n\"\"\"\n    Optimizing unit commitment from a distributed energy network.\n\n    The optimizer has been adapted from the work in:\n        Akshay Ajagekar and Fengqi You. Quantum computing for energy\n        systems optimization: Challenges and opportunities. Energy 179 (2019).\n        https://doi.org/10.1016/j.energy.2019.04.186\n    \"\"\"\n\n    REQUIRED_PARAMS = [\"A\", \"B\", \"C\", \"P_min\", \"P_max\", \"L\", \"N\"]\n\n    def __init__(self, params) -&gt; None:\n\"\"\"\n        Set up DistributedEnergyOptimizer object.\n\n        Args:\n            params (dict): required params specificed by REQUIRED_PARAMS\n                key (str): param name\n                val (Any): param values\n        \"\"\"\n\n        for label in self.REQUIRED_PARAMS:  # make sure we have all the required params\n            if label not in params:\n                raise ValueError(f\"Please provide {label} in params.\")\n\n        self.params = params.copy()\n        self.params[\"alpha\"] = params.get(\"alpha\", 5e5)\n        self.params[\"beta\"] = params.get(\"beta\", 8)\n        self.params[\"n\"] = len(self.params[\"A\"])\n\n        self.params[\"plant_names\"] = params.get(\n            \"plant_names\", [f\"plant_{i}\" for i in range(self.params[\"n\"])]\n        )\n\n        self.results: Dict[str, DistributedEnergyOptimizerResults] = {}\n        self._quadratic_program: Optional[QuadraticProgram] = None\n        self._linear_terms: Optional[Dict[str, float]] = None\n        self._quadratic_terms: Optional[Dict[Tuple[str, str], float]] = None\n        self._offset: Optional[float] = None\n\n    @property\n    def offset(self) -&gt; float:\n\"\"\"\n        Offset term property\n        \"\"\"\n        if self._offset is None:\n            self._linear_terms, self._quadratic_terms, self._offset = self.gen_coeff()\n        return self._offset\n\n    @property\n    def linear_terms(self) -&gt; Dict[str, float]:\n\"\"\"\n        Linear terms property\n        \"\"\"\n        if self._linear_terms is None:\n            self._linear_terms, self._quadratic_terms, self._offset = self.gen_coeff()\n        return self._linear_terms\n\n    @property\n    def quadratic_terms(self) -&gt; Dict[Tuple[str, str], float]:\n\"\"\"\n        Quadratics terms property\n        \"\"\"\n        if self._quadratic_terms is None:\n            self._linear_terms, self._quadratic_terms, self._offset = self.gen_coeff()\n        return self._quadratic_terms\n\n    @property\n    def quadratic_program(self) -&gt; QuadraticProgram:\n\"\"\"\n        Quadratic program property\n        \"\"\"\n        if self._quadratic_program is None:\n            self._quadratic_program = self.gen_quadratic_program()\n        return self._quadratic_program\n\n    def parse_params(\n        self, arr: List[int], arr_keys: List[str]\n    ) -&gt; Tuple[List[int], Dict[Tuple[int, int], int], List[float]]:\n\"\"\"\n        Parse optimal binary state vectors.\n\n        Args:\n            arr (List[int]):\n                List of 0/1s that represents the state of the binary optimization vars.\n                E.g. [0, 0, 0, 1, 1, 0]\n\n            arr_keys (List[str]):\n                List of binary optimization variable names corresponding to the state\n                values in the arr input.\n                E.g. [\"xv0\", \"xv1\", \"xz00\", \"xz01\", \"xz10\", \"xz11\"]\n\n        Returns:\n            vs (List[int]):\n                List of 0/1s representing whether a power plant is used or not,\n                where 0 is turned on and 1 is turned off. This list has n elements,\n                where n is the number of plants.\n\n            zs (Dict[Tuple[int,int], int]):\n                key (Tuple[int,int]): (i,j) where i represents plant and j represents power level\n                val (int): 0/1 representing whether plant i is outputting power level j\n\n            ps (List[float]):\n                List of power levels outputted by each plant. This list has n elements,\n                where n is the number of plants.\n        \"\"\"\n        num_qubits = len(arr)\n        n = self.params[\"n\"]\n        N = self.params[\"N\"]\n        vs = [0 for _ in range(n)]\n        zs: Dict[Tuple[int, int], int] = {}\n\n        for i in range(num_qubits):\n            val = arr[i]\n            key = arr_keys[i]\n\n            # getting v values\n            if key[0:2] == \"xv\":\n                v_indx = int(key[2:])\n                vs[v_indx] = val\n\n            if key[0:2] == \"xz\":\n                z_indx_str = key[2:]\n                i, j = [int(x) for x in z_indx_str.split(\",\")]\n                zs[(i, j)] = val\n\n        ps = [0.0 for _ in range(n)]\n\n        for i in range(n):\n            p_min_val = self.params[\"P_min\"][i]\n            p_max_val = self.params[\"P_max\"][i]\n            h_val = (p_max_val - p_min_val) / N\n\n            if vs[i] == 1:\n                continue\n\n            curr_max_indx = 0\n            for k in range(N + 1):\n                if zs[(i, k)] == 1:\n                    curr_max_indx = k\n\n            ps[i] = p_min_val + h_val * curr_max_indx\n\n        return vs, zs, ps\n\n    def gen_coeff(self) -&gt; Tuple[Dict[str, float], Dict[Tuple[str, str], float], float]:\n\"\"\"\n        Based on the parameters provided and stored in self.params.\n\n        Returns:\n            linear_terms (Dict[str, float]): 4.2*(\"xz0,1\")\n                key (str): represents variable name. E.g. \"xz0,1\"\n                val (str): coefficient of linear term. E.g. 4.2\n\n            quadratic_terms (Dict[Tuple[str,str], float]): 3.2*(\"xz1,2\")*(\"xz3,0\")\n                key (Tuple[str,str]): represents cross term between two binary variables. E.g. (\"xz1,2\". \"xz3,0\")\n                val (float): coefficient of that cross term. E.g. 3.2\n\n            offset (float):\n                constant offset\n        \"\"\"\n        # setup\n        # ==========================================================================\n        # parameters\n        A = self.params[\"A\"]\n        B = self.params[\"B\"]\n        C = self.params[\"C\"]\n        N = self.params[\"N\"]\n        n = self.params[\"n\"]\n        p_min = self.params[\"P_min\"]\n        p_max = self.params[\"P_max\"]\n        alpha = self.params[\"alpha\"]\n        beta = self.params[\"beta\"]\n        L = self.params[\"L\"]\n\n        # helpers\n        def zindx(i: int, k: int) -&gt; str:\n            return \"xz%s,%s\" % (i, k)\n\n        def vindx(i: int) -&gt; str:\n            return \"xv%s\" % i\n\n        h = []\n        for i in range(len(p_min)):\n            h.append((p_max[i] - p_min[i]) / N)\n\n        linear_terms: Dict[str, float] = {}\n        quadratic_terms: Dict[Tuple[str, str], float] = {}\n        offset = 0.0\n\n        # cost function\n        # ==========================================================================\n        # sum_i A_i (1-v_i) done\n        for i in range(n):\n            linear_terms[vindx(i)] = -A[i]\n            offset += A[i]\n\n        # sum_i B_i p_i done\n        for i in range(n):\n            for k in range(0, N + 1):\n                val = B[i] * (p_min[i] + k * h[i])\n                linear_terms[zindx(i, k)] = val\n\n        # sum_i C_i p_i^2 done\n        for i in range(n):\n            for k in range(0, N + 1):\n                for m in range(k, N + 1):\n                    if m == k:\n                        linear_terms[zindx(i, k)] = (\n                            linear_terms.get(zindx(i, k), 0)\n                            + C[i] * (p_min[i] + k * h[i]) ** 2\n                        )\n                        continue\n                    label1 = (zindx(i, k), zindx(i, m))\n                    quadratic_terms[label1] = quadratic_terms.get(label1, 0) + 2 * C[\n                        i\n                    ] * (p_min[i] + k * h[i]) * (p_min[i] + m * h[i])\n\n        # alpha sum_i (v_i + sum_k z_ik - 1)^2\n        for i in range(n):\n            linear_terms[vindx(i)] = linear_terms.get(vindx(i), 0) - alpha\n            for k in range(0, N + 1):\n                linear_terms[zindx(i, k)] += -2 * alpha\n                label2 = (vindx(i), zindx(i, k))\n                quadratic_terms[label2] = quadratic_terms.get(label2, 0) + 2 * alpha\n                for m in range(k, N + 1):\n                    if m == k:\n                        linear_terms[zindx(i, k)] += alpha\n                        continue\n\n                    label3 = (zindx(i, k), zindx(i, m))\n                    quadratic_terms[label3] += 2 * alpha\n            offset += alpha\n\n        # sum_i p_i = L done\n        for i in range(n):\n            for k in range(0, N + 1):\n                linear_terms[zindx(i, k)] += -2 * beta * L * (p_min[i] + k * h[i])\n                for j in range(i, n):\n                    for m in range(k, N + 1):\n                        if i == j and m == k:\n                            linear_terms[zindx(i, k)] += (\n                                beta * (p_min[i] + k * h[i]) ** 2\n                            )\n                            continue\n                        label4 = (zindx(i, k), zindx(j, m))\n\n                        quadratic_terms[label4] = quadratic_terms.get(\n                            label4, 0\n                        ) + 2 * beta * (p_min[i] + k * h[i]) * (p_min[j] + m * h[j])\n\n        offset += beta * L**2\n\n        return linear_terms, quadratic_terms, offset\n\n    # IBM\n    # ==============================================================================\n    def gen_quadratic_program(self) -&gt; QuadraticProgram:\n\"\"\"\n        Generates Qiskit QuadraticProgram object based on linear terms, quadratic terms,\n        and offset of the problem at hand.\n\n        Returns:\n            qubo (QuadraticProgram):\n                Qiskit QuadraticProgram object describing QUBO optimization problem.\n        \"\"\"\n        qubo = QuadraticProgram(name=\"energy\")\n        n = self.params[\"n\"]\n        N = self.params[\"N\"]\n\n        qubo.binary_var_dict(n, key_format=\"v{}\")\n        for i in range(n):\n            qubo.binary_var_dict(\n                key_format=\"z\" + str(i) + \",{}\", keys=list(range(N + 1))\n            )\n\n        qubo.minimize(\n            linear=self.linear_terms,\n            quadratic=self.quadratic_terms,\n            constant=self.offset,\n        )\n        return qubo\n\n    def _run_gate_based_opt(\n        self,\n        quantum_instance: Optional[QuantumInstance] = None,\n        label: str = \"qaoa\",\n        opt_type: str = \"qaoa\",\n    ) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n        Base function for gate based QAOA or VQE optimization methods.\n\n        Args:\n            quantum_instance (Optional[QuantumInstance]):\n                Qiskit backend on which to run quantum optimization.\n\n            label (str):\n                label to use for results\n\n            opt_type (str):\n                \"qaoa\" or \"vqe\"\n\n        Returns:\n            results (DistributedEnergyOptimizerResults):\n                results from optimization\n        \"\"\"\n        opt_types = {\"qaoa\": QAOA, \"vqe\": VQE}\n        quantum_algo = opt_types[opt_type]\n\n        if quantum_instance is None:\n            backend = Aer.get_backend(\"qasm_simulator\")\n            quantum_instance = QuantumInstance(\n                backend=backend,\n                seed_simulator=algorithm_globals.random_seed,\n                seed_transpiler=algorithm_globals.random_seed,\n            )\n        quadprog = self.quadratic_program\n\n        _eval_count = 0\n\n        def callback(eval_count, parameters, mean, std):\n            nonlocal _eval_count\n            _eval_count = eval_count\n\n        # Create solver\n        solver = quantum_algo(\n            quantum_instance=quantum_instance,\n            callback=callback,\n        )\n\n        # Create optimizer for solver\n        optimizer = MinimumEigenOptimizer(solver)\n\n        # Get result from optimizer\n        result = optimizer.solve(quadprog)\n\n        self.results[label] = DistributedEnergyOptimizerResults(\n            result, {\"eval_count\": _eval_count}\n        )\n        return self.results[label]\n\n    def run_qaoa(\n        self, quantum_instance: Optional[QuantumInstance] = None, label: str = \"qaoa\"\n    ) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n        QAOA Optimization method.\n\n        Args:\n            quantum_instance (Optional[QuantumInstance]):\n                Qiskit backend on which to run quantum optimization.\n\n            label (str):\n                label to use for results\n\n        Returns:\n            result (DistributedEnergyOptimizerResults):\n                results from optimization\n        \"\"\"\n        return self._run_gate_based_opt(\n            quantum_instance=quantum_instance,\n            label=label,\n            opt_type=\"qaoa\",\n        )\n\n    def run_vqe(\n        self, quantum_instance: Optional[QuantumInstance] = None, label: str = \"vqe\"\n    ) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n        VQE Optimization method.\n\n        Args:\n            quantum_instance (Optional[QuantumInstance]):\n                Qiskit backend on which to run quantum optimization.\n\n            label (str):\n                label to use for results\n\n        Returns:\n            result (DistributedEnergyOptimizerResults):\n                results from optimization\n        \"\"\"\n        return self._run_gate_based_opt(\n            quantum_instance=quantum_instance,\n            label=label,\n            opt_type=\"vqe\",\n        )\n\n    def run_grover(\n        self,\n        quantum_instance: Optional[QuantumInstance] = None,\n        label: str = \"grover\",\n        num_iterations=100,\n    ) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n        Grover Optimization method.\n\n        Args:\n            quantum_instance (Optional[QuantumInstance]):\n                Qiskit backend on which to run quantum optimization.\n\n            label (str):\n                label to use for results\n\n            num_iterations (int):\n                number of iterations to run with grover\n\n        Returns:\n            result (DistributedEnergyOptimizerResults):\n                results from optimization\n        \"\"\"\n        if quantum_instance is None:\n            backend = Aer.get_backend(\"qasm_simulator\")\n            quantum_instance = QuantumInstance(\n                backend=backend,\n                seed_simulator=algorithm_globals.random_seed,\n                seed_transpiler=algorithm_globals.random_seed,\n            )\n\n        quadprog = self.quadratic_program\n\n        n = self.params[\"n\"]\n        N = self.params[\"N\"]\n        num_qubits = n + N * n\n        optimizer = GroverOptimizer(\n            num_qubits, num_iterations=num_iterations, quantum_instance=backend\n        )\n\n        # Get result from optimizer\n        result = optimizer.solve(quadprog)\n\n        self.results[label] = DistributedEnergyOptimizerResults(result)\n        return self.results[label]\n\n    def run_classical(\n        self, label: str = \"classical\"\n    ) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n        Classical Optimization method.\n\n        Args:\n            label (str):\n                label to use for results\n\n        Returns:\n            result (DistributedEnergyOptimizerResults):\n                results from optimization\n        \"\"\"\n        solver = NumPyMinimumEigensolver()\n\n        # Create optimizer for solver\n        optimizer = MinimumEigenOptimizer(solver)\n\n        # Get result from optimizer\n        result = optimizer.solve(self.quadratic_program)\n\n        self.results[label] = DistributedEnergyOptimizerResults(result)\n        return self.results[label]\n\n    # D-WAVE\n    # ==============================================================================\n    def _convert_coeff(self):\n\"\"\"\n        Convert coefficients that use {1,-1} instead of {0,1} for the binary variables.\n\n        Map:\n            0 -&gt;  1\n            1 -&gt; -1\n            x -&gt; y\n            x = (1-y)/2\n\n        ax1 -&gt; a(1-x1)/2\n            -&gt; offset: a/2\n            -&gt; linear: (- a/2) x1\n\n        cx1x2 -&gt; c(1 - x1)(1-x2)/4\n              -&gt; offset: c/4\n              -&gt; linear: (-c/4) x1\n              -&gt; linear: (-c/4) x2\n              -&gt; quadratic: (c/4) x1x2\n        \"\"\"\n        new_linear_terms = {}\n        new_quadratic_terms = {}\n        new_offset = self.offset\n\n        # linear terms\n        for var_name, coeff in self.linear_terms.items():\n            new_offset += coeff / 2.0\n            new_linear_terms[var_name] = new_linear_terms.get(var_name, 0) + (\n                -coeff / 2.0\n            )\n\n        # quadratic terms\n        for var_names, coeff in self.quadratic_terms.items():\n            new_offset += coeff / 4\n            var_name1, var_name2 = var_names\n            new_linear_terms[var_name1] = new_linear_terms.get(var_name1, 0) + (\n                -coeff / 4\n            )\n            new_linear_terms[var_name2] = new_linear_terms.get(var_name2, 0) + (\n                -coeff / 4\n            )\n            new_quadratic_terms[var_names] = new_quadratic_terms.get(var_names, 0) + (\n                coeff / 4\n            )\n        return new_linear_terms, new_quadratic_terms, new_offset\n\n    def convert_basis(self, y: int) -&gt; int:\n\"\"\"\n        Convert coefficients that use {1,-1} instead of {0,1} for the binary variables.\n\n        Map:\n            1  -&gt; 0\n            -1 -&gt; 1\n            y  -&gt; x\n            x  =  (1-y)/2\n        \"\"\"\n        return int((1 - y) / 2)\n\n    def run_annealer_sim(\n        self, label: str = \"annealer_sim\", num_shots: int = 100\n    ) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n        Annealer Optimization method run on a simulator.\n\n        Args:\n            label (str):\n                label to use for results\n\n            num_shots (int):\n                number of shots to run on the experiment\n\n        Returns:\n            result (DistributedEnergyOptimizerResults):\n                results from optimization\n        \"\"\"\n        vartype = dimod.SPIN\n\n        # run classical simulated annealing\n        linear_terms, quadratic_terms, offset = self._convert_coeff()\n\n        model = dimod.BinaryQuadraticModel(\n            linear_terms, quadratic_terms, offset=offset, vartype=vartype\n        )\n        sampler = dimod.SimulatedAnnealingSampler()\n        response = sampler.sample(model, num_reads=num_shots)\n\n        # store results\n        energies = response.record[\"energy\"]\n        min_indx = np.argmin(energies)\n        opt_values = response.record[\"sample\"][min_indx]\n        opt_values = [self.convert_basis(y) for y in opt_values]\n        names = list(response.variables)\n        self.results[label] = DistributedEnergyOptimizerResults(\n            response,\n            {\n                \"opt_cost\": energies[min_indx],\n                \"opt_state\": opt_values,\n                \"names\": names,\n                \"num_shots\": num_shots,\n            },\n        )\n        return self.results[label]\n\n    def run_annealer_qpu(\n        self,\n        label: str = \"annealer_qpu\",\n        num_shots: int = 100,\n        device_name: str = \"DW_2000Q_6\",\n    ) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n        Annealer Optimization method run on DWAVE annealers.\n\n        Args:\n            label (str):\n                label to use for results\n\n            num_shots (int):\n                number of shots to run on the experiment\n\n            device_name (str):\n                DWAVE device name. E.g. \"DW_2000Q_6\"\n\n        Returns:\n            result (DistributedEnergyOptimizerResults):\n                results from optimization\n        \"\"\"\n\n        device = \"arn:aws:braket:::device/qpu/d-wave/\" + device_name\n        vartype = dimod.SPIN\n\n        # define BQM\n        linear_terms, quadratic_terms, offset = self._convert_coeff()\n\n        model = dimod.BinaryQuadraticModel(\n            linear_terms, quadratic_terms, offset=offset, vartype=vartype\n        )\n\n        s3_folder = (\"amazon-braket-qbraid-jobs\", \"5f2001ee89-40iitp-2eac-2ein\")\n\n        # run BQM: solve with the D-Wave device\n        sampler = BraketDWaveSampler(s3_folder, device_arn=device)\n        sampler = EmbeddingComposite(sampler)\n        response = sampler.sample(model, num_reads=num_shots)\n\n        # store results\n        energies = response.record[\"energy\"]\n        min_indx = np.argmin(energies)\n        opt_values = response.record[\"sample\"][min_indx]\n        opt_values = [self.convert_basis(y) for y in opt_values]\n        names = list(response.variables)\n        self.results[label] = DistributedEnergyOptimizerResults(\n            response,\n            {\n                \"opt_cost\": energies[min_indx],\n                \"opt_state\": opt_values,\n                \"names\": names,\n                \"num_shots\": num_shots,\n            },\n        )\n        return self.results[label]\n\n    # Visualizations\n    # ==============================================================================\n    def print_results(self, label: str = \"qaoa\") -&gt; None:\n\"\"\"\n        Print results.\n\n        Args:\n            label (str):\n                label to use when extracting optimization results\n        \"\"\"\n        results = self.results[label]\n        if label in [\"qaoa\", \"vqe\", \"grover\", \"classical\"]:\n            eval_count = results.extras.get(\"eval_count\", 0)\n\n            print(f\"Solution found using the {label} method:\\n\")\n            print(f\"Minimum Cost: {results.results.fval} ul\")\n            print(f\"Optimal State: \")\n            for source_contribution, source_name in zip(\n                results.results.x, results.results.variable_names\n            ):\n                print(f\"{source_name}:\\t{source_contribution}\")\n\n            print(\n                f\"\\nThe solution was found within {eval_count} evaluations of {label}.\"\n            )\n        elif label[:8] == \"annealer\":\n            print(f\"Solution found using the {label} method:\\n\")\n            opt_cost = results.extras[\"opt_cost\"]\n            print(f\"Minimum Cost: {opt_cost} ul\")\n            print(f\"Optimal State: \")\n            for source_contribution, source_name in zip(\n                results.extras[\"opt_state\"], results.extras[\"names\"]\n            ):\n                print(f\"{source_name}:\\t{source_contribution}\")\n            num_shots = results.extras[\"num_shots\"]\n            print(f\"\\nThe solution was found with {num_shots} shots of {label}.\")\n        else:\n            raise NotImplementedError(f\"This method is not implemented yet for {label}\")\n\n    def plot_histogram(self, label=\"qaoa\") -&gt; None:\n\"\"\"\n        Output results in bar chart.\n\n        Args:\n            label (str):\n                label to identify results\n        \"\"\"\n\n        if label in [\"qaoa\", \"vqe\", \"grover\", \"classical\"] or label[:8] == \"annealer\":\n            plant_names = self.params[\"plant_names\"]\n            P_min = self.params[\"P_min\"]\n            P_max = self.params[\"P_max\"]\n        else:\n            raise NotImplementedError(f\"This method is not implemented yet for {label}\")\n\n        print(f\"Plot using the {label} method:\\n\")\n\n        if label in [\"qaoa\", \"vqe\", \"grover\", \"classical\"]:\n            results = self.results[label].results\n            var_values = results.x\n            var_names = results.variable_names\n\n        elif label[:8] == \"annealer\":\n            var_values = self.results[label].extras[\"opt_state\"]\n            var_names = self.results[label].extras[\"names\"]\n\n        _, _, P = self.parse_params(var_values, var_names)\n        fig = plt.figure(figsize=(8, 6), dpi=200)\n        _ = fig.add_axes([0, 0, 1, 1])\n        sns.barplot(\n            x=plant_names,\n            y=P_max,\n            errcolor=\".2\",\n            edgecolor=\".2\",\n            facecolor=(1, 1, 1, 0),\n        )\n        sns.barplot(x=plant_names, y=P_min, color=\"gainsboro\", edgecolor=\".2\")\n        sns.barplot(x=plant_names, y=P, color=\"palegreen\", edgecolor=\".2\")\n        rcParams[\"figure.figsize\"] = 2, 3\n        plt.show()\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.linear_terms","title":"<code>linear_terms: Dict[str, float]</code>  <code>property</code>","text":"<p>Linear terms property</p>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.offset","title":"<code>offset: float</code>  <code>property</code>","text":"<p>Offset term property</p>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.quadratic_program","title":"<code>quadratic_program: QuadraticProgram</code>  <code>property</code>","text":"<p>Quadratic program property</p>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.quadratic_terms","title":"<code>quadratic_terms: Dict[Tuple[str, str], float]</code>  <code>property</code>","text":"<p>Quadratics terms property</p>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.__init__","title":"<code>__init__(params)</code>","text":"<p>Set up DistributedEnergyOptimizer object.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>required params specificed by REQUIRED_PARAMS key (str): param name val (Any): param values</p> required Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def __init__(self, params) -&gt; None:\n\"\"\"\n    Set up DistributedEnergyOptimizer object.\n\n    Args:\n        params (dict): required params specificed by REQUIRED_PARAMS\n            key (str): param name\n            val (Any): param values\n    \"\"\"\n\n    for label in self.REQUIRED_PARAMS:  # make sure we have all the required params\n        if label not in params:\n            raise ValueError(f\"Please provide {label} in params.\")\n\n    self.params = params.copy()\n    self.params[\"alpha\"] = params.get(\"alpha\", 5e5)\n    self.params[\"beta\"] = params.get(\"beta\", 8)\n    self.params[\"n\"] = len(self.params[\"A\"])\n\n    self.params[\"plant_names\"] = params.get(\n        \"plant_names\", [f\"plant_{i}\" for i in range(self.params[\"n\"])]\n    )\n\n    self.results: Dict[str, DistributedEnergyOptimizerResults] = {}\n    self._quadratic_program: Optional[QuadraticProgram] = None\n    self._linear_terms: Optional[Dict[str, float]] = None\n    self._quadratic_terms: Optional[Dict[Tuple[str, str], float]] = None\n    self._offset: Optional[float] = None\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.convert_basis","title":"<code>convert_basis(y)</code>","text":"<p>Convert coefficients that use {1,-1} instead of {0,1} for the binary variables.</p> Map <p>1  -&gt; 0 -1 -&gt; 1 y  -&gt; x x  =  (1-y)/2</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def convert_basis(self, y: int) -&gt; int:\n\"\"\"\n    Convert coefficients that use {1,-1} instead of {0,1} for the binary variables.\n\n    Map:\n        1  -&gt; 0\n        -1 -&gt; 1\n        y  -&gt; x\n        x  =  (1-y)/2\n    \"\"\"\n    return int((1 - y) / 2)\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.gen_coeff","title":"<code>gen_coeff()</code>","text":"<p>Based on the parameters provided and stored in self.params.</p> <p>Returns:</p> Name Type Description <code>linear_terms</code> <code>Dict[str, float]</code> <p>4.2*(\"xz0,1\") key (str): represents variable name. E.g. \"xz0,1\" val (str): coefficient of linear term. E.g. 4.2</p> <code>quadratic_terms</code> <code>Dict[Tuple[str, str], float]</code> <p>3.2(\"xz1,2\")(\"xz3,0\") key (Tuple[str,str]): represents cross term between two binary variables. E.g. (\"xz1,2\". \"xz3,0\") val (float): coefficient of that cross term. E.g. 3.2</p> <code>offset</code> <code>float</code> <p>constant offset</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def gen_coeff(self) -&gt; Tuple[Dict[str, float], Dict[Tuple[str, str], float], float]:\n\"\"\"\n    Based on the parameters provided and stored in self.params.\n\n    Returns:\n        linear_terms (Dict[str, float]): 4.2*(\"xz0,1\")\n            key (str): represents variable name. E.g. \"xz0,1\"\n            val (str): coefficient of linear term. E.g. 4.2\n\n        quadratic_terms (Dict[Tuple[str,str], float]): 3.2*(\"xz1,2\")*(\"xz3,0\")\n            key (Tuple[str,str]): represents cross term between two binary variables. E.g. (\"xz1,2\". \"xz3,0\")\n            val (float): coefficient of that cross term. E.g. 3.2\n\n        offset (float):\n            constant offset\n    \"\"\"\n    # setup\n    # ==========================================================================\n    # parameters\n    A = self.params[\"A\"]\n    B = self.params[\"B\"]\n    C = self.params[\"C\"]\n    N = self.params[\"N\"]\n    n = self.params[\"n\"]\n    p_min = self.params[\"P_min\"]\n    p_max = self.params[\"P_max\"]\n    alpha = self.params[\"alpha\"]\n    beta = self.params[\"beta\"]\n    L = self.params[\"L\"]\n\n    # helpers\n    def zindx(i: int, k: int) -&gt; str:\n        return \"xz%s,%s\" % (i, k)\n\n    def vindx(i: int) -&gt; str:\n        return \"xv%s\" % i\n\n    h = []\n    for i in range(len(p_min)):\n        h.append((p_max[i] - p_min[i]) / N)\n\n    linear_terms: Dict[str, float] = {}\n    quadratic_terms: Dict[Tuple[str, str], float] = {}\n    offset = 0.0\n\n    # cost function\n    # ==========================================================================\n    # sum_i A_i (1-v_i) done\n    for i in range(n):\n        linear_terms[vindx(i)] = -A[i]\n        offset += A[i]\n\n    # sum_i B_i p_i done\n    for i in range(n):\n        for k in range(0, N + 1):\n            val = B[i] * (p_min[i] + k * h[i])\n            linear_terms[zindx(i, k)] = val\n\n    # sum_i C_i p_i^2 done\n    for i in range(n):\n        for k in range(0, N + 1):\n            for m in range(k, N + 1):\n                if m == k:\n                    linear_terms[zindx(i, k)] = (\n                        linear_terms.get(zindx(i, k), 0)\n                        + C[i] * (p_min[i] + k * h[i]) ** 2\n                    )\n                    continue\n                label1 = (zindx(i, k), zindx(i, m))\n                quadratic_terms[label1] = quadratic_terms.get(label1, 0) + 2 * C[\n                    i\n                ] * (p_min[i] + k * h[i]) * (p_min[i] + m * h[i])\n\n    # alpha sum_i (v_i + sum_k z_ik - 1)^2\n    for i in range(n):\n        linear_terms[vindx(i)] = linear_terms.get(vindx(i), 0) - alpha\n        for k in range(0, N + 1):\n            linear_terms[zindx(i, k)] += -2 * alpha\n            label2 = (vindx(i), zindx(i, k))\n            quadratic_terms[label2] = quadratic_terms.get(label2, 0) + 2 * alpha\n            for m in range(k, N + 1):\n                if m == k:\n                    linear_terms[zindx(i, k)] += alpha\n                    continue\n\n                label3 = (zindx(i, k), zindx(i, m))\n                quadratic_terms[label3] += 2 * alpha\n        offset += alpha\n\n    # sum_i p_i = L done\n    for i in range(n):\n        for k in range(0, N + 1):\n            linear_terms[zindx(i, k)] += -2 * beta * L * (p_min[i] + k * h[i])\n            for j in range(i, n):\n                for m in range(k, N + 1):\n                    if i == j and m == k:\n                        linear_terms[zindx(i, k)] += (\n                            beta * (p_min[i] + k * h[i]) ** 2\n                        )\n                        continue\n                    label4 = (zindx(i, k), zindx(j, m))\n\n                    quadratic_terms[label4] = quadratic_terms.get(\n                        label4, 0\n                    ) + 2 * beta * (p_min[i] + k * h[i]) * (p_min[j] + m * h[j])\n\n    offset += beta * L**2\n\n    return linear_terms, quadratic_terms, offset\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.gen_quadratic_program","title":"<code>gen_quadratic_program()</code>","text":"<p>Generates Qiskit QuadraticProgram object based on linear terms, quadratic terms, and offset of the problem at hand.</p> <p>Returns:</p> Name Type Description <code>qubo</code> <code>QuadraticProgram</code> <p>Qiskit QuadraticProgram object describing QUBO optimization problem.</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def gen_quadratic_program(self) -&gt; QuadraticProgram:\n\"\"\"\n    Generates Qiskit QuadraticProgram object based on linear terms, quadratic terms,\n    and offset of the problem at hand.\n\n    Returns:\n        qubo (QuadraticProgram):\n            Qiskit QuadraticProgram object describing QUBO optimization problem.\n    \"\"\"\n    qubo = QuadraticProgram(name=\"energy\")\n    n = self.params[\"n\"]\n    N = self.params[\"N\"]\n\n    qubo.binary_var_dict(n, key_format=\"v{}\")\n    for i in range(n):\n        qubo.binary_var_dict(\n            key_format=\"z\" + str(i) + \",{}\", keys=list(range(N + 1))\n        )\n\n    qubo.minimize(\n        linear=self.linear_terms,\n        quadratic=self.quadratic_terms,\n        constant=self.offset,\n    )\n    return qubo\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.parse_params","title":"<code>parse_params(arr, arr_keys)</code>","text":"<p>Parse optimal binary state vectors.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>List[int]</code> <p>List of 0/1s that represents the state of the binary optimization vars. E.g. [0, 0, 0, 1, 1, 0]</p> required <code>arr_keys</code> <code>List[str]</code> <p>List of binary optimization variable names corresponding to the state values in the arr input. E.g. [\"xv0\", \"xv1\", \"xz00\", \"xz01\", \"xz10\", \"xz11\"]</p> required <p>Returns:</p> Name Type Description <code>vs</code> <code>List[int]</code> <p>List of 0/1s representing whether a power plant is used or not, where 0 is turned on and 1 is turned off. This list has n elements, where n is the number of plants.</p> <code>zs</code> <code>Dict[Tuple[int, int], int]</code> <p>key (Tuple[int,int]): (i,j) where i represents plant and j represents power level val (int): 0/1 representing whether plant i is outputting power level j</p> <code>ps</code> <code>List[float]</code> <p>List of power levels outputted by each plant. This list has n elements, where n is the number of plants.</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def parse_params(\n    self, arr: List[int], arr_keys: List[str]\n) -&gt; Tuple[List[int], Dict[Tuple[int, int], int], List[float]]:\n\"\"\"\n    Parse optimal binary state vectors.\n\n    Args:\n        arr (List[int]):\n            List of 0/1s that represents the state of the binary optimization vars.\n            E.g. [0, 0, 0, 1, 1, 0]\n\n        arr_keys (List[str]):\n            List of binary optimization variable names corresponding to the state\n            values in the arr input.\n            E.g. [\"xv0\", \"xv1\", \"xz00\", \"xz01\", \"xz10\", \"xz11\"]\n\n    Returns:\n        vs (List[int]):\n            List of 0/1s representing whether a power plant is used or not,\n            where 0 is turned on and 1 is turned off. This list has n elements,\n            where n is the number of plants.\n\n        zs (Dict[Tuple[int,int], int]):\n            key (Tuple[int,int]): (i,j) where i represents plant and j represents power level\n            val (int): 0/1 representing whether plant i is outputting power level j\n\n        ps (List[float]):\n            List of power levels outputted by each plant. This list has n elements,\n            where n is the number of plants.\n    \"\"\"\n    num_qubits = len(arr)\n    n = self.params[\"n\"]\n    N = self.params[\"N\"]\n    vs = [0 for _ in range(n)]\n    zs: Dict[Tuple[int, int], int] = {}\n\n    for i in range(num_qubits):\n        val = arr[i]\n        key = arr_keys[i]\n\n        # getting v values\n        if key[0:2] == \"xv\":\n            v_indx = int(key[2:])\n            vs[v_indx] = val\n\n        if key[0:2] == \"xz\":\n            z_indx_str = key[2:]\n            i, j = [int(x) for x in z_indx_str.split(\",\")]\n            zs[(i, j)] = val\n\n    ps = [0.0 for _ in range(n)]\n\n    for i in range(n):\n        p_min_val = self.params[\"P_min\"][i]\n        p_max_val = self.params[\"P_max\"][i]\n        h_val = (p_max_val - p_min_val) / N\n\n        if vs[i] == 1:\n            continue\n\n        curr_max_indx = 0\n        for k in range(N + 1):\n            if zs[(i, k)] == 1:\n                curr_max_indx = k\n\n        ps[i] = p_min_val + h_val * curr_max_indx\n\n    return vs, zs, ps\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.plot_histogram","title":"<code>plot_histogram(label='qaoa')</code>","text":"<p>Output results in bar chart.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>label to identify results</p> <code>'qaoa'</code> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def plot_histogram(self, label=\"qaoa\") -&gt; None:\n\"\"\"\n    Output results in bar chart.\n\n    Args:\n        label (str):\n            label to identify results\n    \"\"\"\n\n    if label in [\"qaoa\", \"vqe\", \"grover\", \"classical\"] or label[:8] == \"annealer\":\n        plant_names = self.params[\"plant_names\"]\n        P_min = self.params[\"P_min\"]\n        P_max = self.params[\"P_max\"]\n    else:\n        raise NotImplementedError(f\"This method is not implemented yet for {label}\")\n\n    print(f\"Plot using the {label} method:\\n\")\n\n    if label in [\"qaoa\", \"vqe\", \"grover\", \"classical\"]:\n        results = self.results[label].results\n        var_values = results.x\n        var_names = results.variable_names\n\n    elif label[:8] == \"annealer\":\n        var_values = self.results[label].extras[\"opt_state\"]\n        var_names = self.results[label].extras[\"names\"]\n\n    _, _, P = self.parse_params(var_values, var_names)\n    fig = plt.figure(figsize=(8, 6), dpi=200)\n    _ = fig.add_axes([0, 0, 1, 1])\n    sns.barplot(\n        x=plant_names,\n        y=P_max,\n        errcolor=\".2\",\n        edgecolor=\".2\",\n        facecolor=(1, 1, 1, 0),\n    )\n    sns.barplot(x=plant_names, y=P_min, color=\"gainsboro\", edgecolor=\".2\")\n    sns.barplot(x=plant_names, y=P, color=\"palegreen\", edgecolor=\".2\")\n    rcParams[\"figure.figsize\"] = 2, 3\n    plt.show()\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.print_results","title":"<code>print_results(label='qaoa')</code>","text":"<p>Print results.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>label to use when extracting optimization results</p> <code>'qaoa'</code> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def print_results(self, label: str = \"qaoa\") -&gt; None:\n\"\"\"\n    Print results.\n\n    Args:\n        label (str):\n            label to use when extracting optimization results\n    \"\"\"\n    results = self.results[label]\n    if label in [\"qaoa\", \"vqe\", \"grover\", \"classical\"]:\n        eval_count = results.extras.get(\"eval_count\", 0)\n\n        print(f\"Solution found using the {label} method:\\n\")\n        print(f\"Minimum Cost: {results.results.fval} ul\")\n        print(f\"Optimal State: \")\n        for source_contribution, source_name in zip(\n            results.results.x, results.results.variable_names\n        ):\n            print(f\"{source_name}:\\t{source_contribution}\")\n\n        print(\n            f\"\\nThe solution was found within {eval_count} evaluations of {label}.\"\n        )\n    elif label[:8] == \"annealer\":\n        print(f\"Solution found using the {label} method:\\n\")\n        opt_cost = results.extras[\"opt_cost\"]\n        print(f\"Minimum Cost: {opt_cost} ul\")\n        print(f\"Optimal State: \")\n        for source_contribution, source_name in zip(\n            results.extras[\"opt_state\"], results.extras[\"names\"]\n        ):\n            print(f\"{source_name}:\\t{source_contribution}\")\n        num_shots = results.extras[\"num_shots\"]\n        print(f\"\\nThe solution was found with {num_shots} shots of {label}.\")\n    else:\n        raise NotImplementedError(f\"This method is not implemented yet for {label}\")\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.run_annealer_qpu","title":"<code>run_annealer_qpu(label='annealer_qpu', num_shots=100, device_name='DW_2000Q_6')</code>","text":"<p>Annealer Optimization method run on DWAVE annealers.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>label to use for results</p> <code>'annealer_qpu'</code> <code>num_shots</code> <code>int</code> <p>number of shots to run on the experiment</p> <code>100</code> <code>device_name</code> <code>str</code> <p>DWAVE device name. E.g. \"DW_2000Q_6\"</p> <code>'DW_2000Q_6'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DistributedEnergyOptimizerResults</code> <p>results from optimization</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def run_annealer_qpu(\n    self,\n    label: str = \"annealer_qpu\",\n    num_shots: int = 100,\n    device_name: str = \"DW_2000Q_6\",\n) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n    Annealer Optimization method run on DWAVE annealers.\n\n    Args:\n        label (str):\n            label to use for results\n\n        num_shots (int):\n            number of shots to run on the experiment\n\n        device_name (str):\n            DWAVE device name. E.g. \"DW_2000Q_6\"\n\n    Returns:\n        result (DistributedEnergyOptimizerResults):\n            results from optimization\n    \"\"\"\n\n    device = \"arn:aws:braket:::device/qpu/d-wave/\" + device_name\n    vartype = dimod.SPIN\n\n    # define BQM\n    linear_terms, quadratic_terms, offset = self._convert_coeff()\n\n    model = dimod.BinaryQuadraticModel(\n        linear_terms, quadratic_terms, offset=offset, vartype=vartype\n    )\n\n    s3_folder = (\"amazon-braket-qbraid-jobs\", \"5f2001ee89-40iitp-2eac-2ein\")\n\n    # run BQM: solve with the D-Wave device\n    sampler = BraketDWaveSampler(s3_folder, device_arn=device)\n    sampler = EmbeddingComposite(sampler)\n    response = sampler.sample(model, num_reads=num_shots)\n\n    # store results\n    energies = response.record[\"energy\"]\n    min_indx = np.argmin(energies)\n    opt_values = response.record[\"sample\"][min_indx]\n    opt_values = [self.convert_basis(y) for y in opt_values]\n    names = list(response.variables)\n    self.results[label] = DistributedEnergyOptimizerResults(\n        response,\n        {\n            \"opt_cost\": energies[min_indx],\n            \"opt_state\": opt_values,\n            \"names\": names,\n            \"num_shots\": num_shots,\n        },\n    )\n    return self.results[label]\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.run_annealer_sim","title":"<code>run_annealer_sim(label='annealer_sim', num_shots=100)</code>","text":"<p>Annealer Optimization method run on a simulator.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>label to use for results</p> <code>'annealer_sim'</code> <code>num_shots</code> <code>int</code> <p>number of shots to run on the experiment</p> <code>100</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DistributedEnergyOptimizerResults</code> <p>results from optimization</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def run_annealer_sim(\n    self, label: str = \"annealer_sim\", num_shots: int = 100\n) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n    Annealer Optimization method run on a simulator.\n\n    Args:\n        label (str):\n            label to use for results\n\n        num_shots (int):\n            number of shots to run on the experiment\n\n    Returns:\n        result (DistributedEnergyOptimizerResults):\n            results from optimization\n    \"\"\"\n    vartype = dimod.SPIN\n\n    # run classical simulated annealing\n    linear_terms, quadratic_terms, offset = self._convert_coeff()\n\n    model = dimod.BinaryQuadraticModel(\n        linear_terms, quadratic_terms, offset=offset, vartype=vartype\n    )\n    sampler = dimod.SimulatedAnnealingSampler()\n    response = sampler.sample(model, num_reads=num_shots)\n\n    # store results\n    energies = response.record[\"energy\"]\n    min_indx = np.argmin(energies)\n    opt_values = response.record[\"sample\"][min_indx]\n    opt_values = [self.convert_basis(y) for y in opt_values]\n    names = list(response.variables)\n    self.results[label] = DistributedEnergyOptimizerResults(\n        response,\n        {\n            \"opt_cost\": energies[min_indx],\n            \"opt_state\": opt_values,\n            \"names\": names,\n            \"num_shots\": num_shots,\n        },\n    )\n    return self.results[label]\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.run_classical","title":"<code>run_classical(label='classical')</code>","text":"<p>Classical Optimization method.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>label to use for results</p> <code>'classical'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DistributedEnergyOptimizerResults</code> <p>results from optimization</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def run_classical(\n    self, label: str = \"classical\"\n) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n    Classical Optimization method.\n\n    Args:\n        label (str):\n            label to use for results\n\n    Returns:\n        result (DistributedEnergyOptimizerResults):\n            results from optimization\n    \"\"\"\n    solver = NumPyMinimumEigensolver()\n\n    # Create optimizer for solver\n    optimizer = MinimumEigenOptimizer(solver)\n\n    # Get result from optimizer\n    result = optimizer.solve(self.quadratic_program)\n\n    self.results[label] = DistributedEnergyOptimizerResults(result)\n    return self.results[label]\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.run_grover","title":"<code>run_grover(quantum_instance=None, label='grover', num_iterations=100)</code>","text":"<p>Grover Optimization method.</p> <p>Parameters:</p> Name Type Description Default <code>quantum_instance</code> <code>Optional[QuantumInstance]</code> <p>Qiskit backend on which to run quantum optimization.</p> <code>None</code> <code>label</code> <code>str</code> <p>label to use for results</p> <code>'grover'</code> <code>num_iterations</code> <code>int</code> <p>number of iterations to run with grover</p> <code>100</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DistributedEnergyOptimizerResults</code> <p>results from optimization</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def run_grover(\n    self,\n    quantum_instance: Optional[QuantumInstance] = None,\n    label: str = \"grover\",\n    num_iterations=100,\n) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n    Grover Optimization method.\n\n    Args:\n        quantum_instance (Optional[QuantumInstance]):\n            Qiskit backend on which to run quantum optimization.\n\n        label (str):\n            label to use for results\n\n        num_iterations (int):\n            number of iterations to run with grover\n\n    Returns:\n        result (DistributedEnergyOptimizerResults):\n            results from optimization\n    \"\"\"\n    if quantum_instance is None:\n        backend = Aer.get_backend(\"qasm_simulator\")\n        quantum_instance = QuantumInstance(\n            backend=backend,\n            seed_simulator=algorithm_globals.random_seed,\n            seed_transpiler=algorithm_globals.random_seed,\n        )\n\n    quadprog = self.quadratic_program\n\n    n = self.params[\"n\"]\n    N = self.params[\"N\"]\n    num_qubits = n + N * n\n    optimizer = GroverOptimizer(\n        num_qubits, num_iterations=num_iterations, quantum_instance=backend\n    )\n\n    # Get result from optimizer\n    result = optimizer.solve(quadprog)\n\n    self.results[label] = DistributedEnergyOptimizerResults(result)\n    return self.results[label]\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.run_qaoa","title":"<code>run_qaoa(quantum_instance=None, label='qaoa')</code>","text":"<p>QAOA Optimization method.</p> <p>Parameters:</p> Name Type Description Default <code>quantum_instance</code> <code>Optional[QuantumInstance]</code> <p>Qiskit backend on which to run quantum optimization.</p> <code>None</code> <code>label</code> <code>str</code> <p>label to use for results</p> <code>'qaoa'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DistributedEnergyOptimizerResults</code> <p>results from optimization</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def run_qaoa(\n    self, quantum_instance: Optional[QuantumInstance] = None, label: str = \"qaoa\"\n) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n    QAOA Optimization method.\n\n    Args:\n        quantum_instance (Optional[QuantumInstance]):\n            Qiskit backend on which to run quantum optimization.\n\n        label (str):\n            label to use for results\n\n    Returns:\n        result (DistributedEnergyOptimizerResults):\n            results from optimization\n    \"\"\"\n    return self._run_gate_based_opt(\n        quantum_instance=quantum_instance,\n        label=label,\n        opt_type=\"qaoa\",\n    )\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizer.run_vqe","title":"<code>run_vqe(quantum_instance=None, label='vqe')</code>","text":"<p>VQE Optimization method.</p> <p>Parameters:</p> Name Type Description Default <code>quantum_instance</code> <code>Optional[QuantumInstance]</code> <p>Qiskit backend on which to run quantum optimization.</p> <code>None</code> <code>label</code> <code>str</code> <p>label to use for results</p> <code>'vqe'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>DistributedEnergyOptimizerResults</code> <p>results from optimization</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def run_vqe(\n    self, quantum_instance: Optional[QuantumInstance] = None, label: str = \"vqe\"\n) -&gt; DistributedEnergyOptimizerResults:\n\"\"\"\n    VQE Optimization method.\n\n    Args:\n        quantum_instance (Optional[QuantumInstance]):\n            Qiskit backend on which to run quantum optimization.\n\n        label (str):\n            label to use for results\n\n    Returns:\n        result (DistributedEnergyOptimizerResults):\n            results from optimization\n    \"\"\"\n    return self._run_gate_based_opt(\n        quantum_instance=quantum_instance,\n        label=label,\n        opt_type=\"vqe\",\n    )\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizerResults","title":"<code>DistributedEnergyOptimizerResults</code>","text":"Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>class DistributedEnergyOptimizerResults:\n    def __init__(self, results: Any, extras: Optional[Dict[str, Any]] = None) -&gt; None:\n\"\"\"\n        Creates DistributedEnergyOptimizerResults object.\n\n        Args:\n            results (Any):\n                results object produced by optimization problem\n            extras (Dict[str, Any]):\n                key (str): extra label\n                val (Any): extra value\n        \"\"\"\n        self._results: Any = results\n        self._extras: Dict[str, Any] = extras if extras is not None else {}\n\n    @property\n    def results(self) -&gt; Any:\n        return self._results\n\n    @property\n    def extras(self) -&gt; Dict[str, Any]:\n        return self._extras\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.DistributedEnergyOptimizerResults.__init__","title":"<code>__init__(results, extras=None)</code>","text":"<p>Creates DistributedEnergyOptimizerResults object.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>Any</code> <p>results object produced by optimization problem</p> required <code>extras</code> <code>Dict[str, Any]</code> <p>key (str): extra label val (Any): extra value</p> <code>None</code> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def __init__(self, results: Any, extras: Optional[Dict[str, Any]] = None) -&gt; None:\n\"\"\"\n    Creates DistributedEnergyOptimizerResults object.\n\n    Args:\n        results (Any):\n            results object produced by optimization problem\n        extras (Dict[str, Any]):\n            key (str): extra label\n            val (Any): extra value\n    \"\"\"\n    self._results: Any = results\n    self._extras: Dict[str, Any] = extras if extras is not None else {}\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.gen_params_multicost","title":"<code>gen_params_multicost(cost_types, weights, params=None)</code>","text":"<p>Generate model parameters</p> <p>Parameters:</p> Name Type Description Default <code>cost_type</code> <code>dict</code> <p>key (str): e.g. CO2 emissions val (list[tuple(float,float,float)]): [(A, B, C),...] e.g.:     cost_types = {         \"CO2\": [(A1,B1,C1),(A2,B2,C2),(A3,B3,C3)],         \"Efficiency\": [(A1,B1,C1),(A2,B2,C2),(A3,B3,C3)],         \"Transportation Loss\": [(A1,B1,C1),(A2,B2,C2),(A3,B3,C3)],     }</p> required <p>Returns:</p> Name Type Description <code>params</code> <code>dict</code> <p>key (str): parameter name val (Any): usually float or list or something of the like</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def gen_params_multicost(\n    cost_types: Dict[str, List[Tuple[float, float, float]]],\n    weights: Dict[str, float],\n    params: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n\"\"\"\n    Generate model parameters\n\n    Args:\n        cost_type (dict):\n            key (str): e.g. CO2 emissions\n            val (list[tuple(float,float,float)]): [(A, B, C),...]\n            e.g.:\n                cost_types = {\n                    \"CO2\": [(A1,B1,C1),(A2,B2,C2),(A3,B3,C3)],\n                    \"Efficiency\": [(A1,B1,C1),(A2,B2,C2),(A3,B3,C3)],\n                    \"Transportation Loss\": [(A1,B1,C1),(A2,B2,C2),(A3,B3,C3)],\n                }\n\n    Returns:\n        params (dict):\n            key (str): parameter name\n            val (Any): usually float or list or something of the like\n\n    \"\"\"\n\n    params = params if params is not None else {}\n\n    params[\"n\"] = params.get(\"n\", len(list(cost_types.values())[0]))\n    params[\"A\"] = [0 for _ in range(params[\"n\"])]\n    params[\"B\"] = [0 for _ in range(params[\"n\"])]\n    params[\"C\"] = [0 for _ in range(params[\"n\"])]\n\n    for cost_type, costs in cost_types.items():\n        for plant_indx in range(params[\"n\"]):\n            params[\"A\"][plant_indx] += weights[cost_type] * costs[plant_indx][0]\n            params[\"B\"][plant_indx] += weights[cost_type] * costs[plant_indx][1]\n            params[\"C\"][plant_indx] += weights[cost_type] * costs[plant_indx][2]\n\n    return params\n</code></pre>"},{"location":"reference/qudra/optimizers/distributed_energy/#qudra.optimizers.distributed_energy.gen_transportation_losses","title":"<code>gen_transportation_losses(distances)</code>","text":"<p>Generate Transportation Losses</p> <p>This is an example for how one may generate transportation losses.</p> <p>start-up cost:          Ai = 0 linear ramp-up cost:    Bi = distance_i/avg_distance quadratic ramp-up cost: Ci = (distance_i - avg_distance)/std_distance</p> <p>Parameters:</p> Name Type Description Default <code>distances</code> <code>List[float]</code> <p>Distances of plants from the center of a city/state/country. This list has n elements, where n is the number of plants.</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>List[Tuple[float, float, float]]</code> <p>List of transportation loss related costs for each plant. Each element has the form (Ai, Bi, Ci) as described above. This list has n elements, where n is the number of plants.</p> Source code in <code>qudra/optimizers/distributed_energy.py</code> <pre><code>def gen_transportation_losses(\n    distances: List[float],\n) -&gt; List[Tuple[float, float, float]]:\n\"\"\"\n    Generate Transportation Losses\n\n    This is an example for how one may generate transportation losses.\n\n    start-up cost:          Ai = 0\n    linear ramp-up cost:    Bi = distance_i/avg_distance\n    quadratic ramp-up cost: Ci = (distance_i - avg_distance)/std_distance\n\n    Args:\n        distances (List[float]):\n            Distances of plants from the center of a city/state/country.\n            This list has n elements, where n is the number of plants.\n\n    Returns:\n        cost (List[Tuple[float,float,float]]):\n            List of transportation loss related costs for each plant.\n            Each element has the form (Ai, Bi, Ci) as described above.\n            This list has n elements, where n is the number of plants.\n    \"\"\"\n    n = len(distances)\n    avg_distance = np.mean(distances)\n    std_distance = np.std(distances)\n    cost: List[Tuple[float, float, float]] = []\n    for i in range(n):\n        cost.append(\n            (\n                0.0,  # Ai\n                distances[i] / avg_distance,  # Bi\n                (distances[i] - avg_distance) / std_distance,  # Ci\n            )\n        )\n    return cost\n</code></pre>"}]}